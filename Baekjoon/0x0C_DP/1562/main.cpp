#include <iostream>

using namespace std;

// #10844 쉬운 계단 수 문제에서 비트마스킹을 이용해서 0~9를 모두 들린 숫자를 찾기
// 10개의 비트를 순서대로 해당 번째를 해당 숫자를 들린 것으로 본다.
// D[n][m] = D[n-1][m-1] + D[n-1][m+1]가 원래 계단 수를 구하는 방법 이었다면
// 이전에 어떤 수들을 들렸는지 안다면 해당 숫자에 이번에 들릴 m을 or 연산해주면 된다.
// D[n][7][0b0010010100] -> n자리에 7으로 끝나는 계단수인데 지금까지 들린 숫자가 2, 4, 7인 상황
// 만약 이 다음에 8을 채운다고 하면 D[n+1][8][0b0010010100 | (1 << 8)] += D[n][7][0b0010010100] 가 반드시 포함된다.

long long D[101][11][1024] = {};

int main()
{
  ios::sync_with_stdio(0);
  cin.tie(0);

  int n;
  cin >> n;
  for (int i = 1; i < 10; i++)
    D[1][i][1 << i] = 1;
  for (int i = 2; i <= n; i++)
  {
    for (int j = 0; j < 10; j++)
    {
      for (int k = 0; k < 1024; k++)
      {
        if (j == 0)
          D[i][j][k | (1 << j)] += D[i - 1][1][k];
        else if (j == 9)
          D[i][j][k | (1 << j)] += D[i - 1][8][k]; 
        else
          D[i][j][k | (1 << j)] += (D[i - 1][j - 1][k] + D[i - 1][j + 1][k]) % 1000000000;
        D[i][j][k | (1 << j)] %= 1000000000;
      }
    }
  }

  long long ans = 0;
  for (int i = 0; i < 10; i++)
  {
    ans = (ans + D[n][i][1023]) % 1000000000;
  }
  
  cout << ans;

  return 0;
}